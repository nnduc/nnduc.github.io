<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Injecting forEach into chained method calls · Duc Ninja</title><meta name="description" content="Injecting forEach into chained method calls - Duc Ninja"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://duc.ninja/atom.xml" title="Duc Ninja"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/duccuimia" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/ducito" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Injecting forEach into chained method calls</h1><div class="post-info">Nov 4, 2017</div><div class="post-content"><p>A few weeks ago a reader <a href="https://twitter.com/jasonalexzurita/status/915972380685516800" target="_blank" rel="noopener">pointed out an error</a> in <a href="https://oleb.net/advanced-swift/" target="_blank" rel="noopener"><em>Advanced Swift</em></a>. We had written this about Swift’s <a href="https://developer.apple.com/documentation/swift/sequence/2906738-foreach" target="_blank" rel="noopener"><code>forEach</code></a> method:</p>
<blockquote>
<p>And it [<code>forEach</code>] really shines as part of a sequence of chained operations. For instance, imagine you’ve chained several calls to <code>map</code> and <code>filter</code> in a single statement, and during debugging you want to log the intermediate values somewhere in the middle of the chain. Inserting a <code>forEach</code> step at the desired position is probably the quickest way to do this.</p>
</blockquote>
<p>I imagine there was a lot of wishful thinking at play when we wrote this because it sounds like a truly useful feature (and it’s something you can’t do with a<code>for</code> - <code>in</code> loop). Alas, it’s completely wrong — you can’t use <code>forEach</code> in the middle of a chain like this!</p>
<h1 id="How-I’d-like-it-to-work"><a href="#How-I’d-like-it-to-work" class="headerlink" title="How I’d like it to work"></a>How I’d like it to work</h1><p>To illustrate the idea with a code sample, let’s say we have chained a number of operations on a sequence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let numbers = 1...10</span><br><span class="line">let sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .filter &#123; $0 % 2 == 0&#125;</span><br><span class="line">    .map &#123; $0 * $0 &#125;</span><br><span class="line">    .reduce(0, +)</span><br><span class="line">// → 220</span><br></pre></td></tr></table></figure>
<p>Now suppose we wanted to check that each of the operations in the chain does what we expect. It’d be really neat if we could insert a call like <code>.forEach { print($0) }</code>somewhere in the middle of that chain to inspect the elements that come out of the <code>filter</code> and/or <code>map</code> operations.</p>
<p>Why doesn’t <code>forEach</code> support this? To appear in the middle of the chain, it would have to return some kind of <a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener"><code>Sequence</code></a> such that the next operation in the chain has something to operate. Because the return type of <code>forEach</code> is <code>()</code>, it can only appear at the end of the chain.</p>
<h1 id="A-forEach-variant-that-returns-Self"><a href="#A-forEach-variant-that-returns-Self" class="headerlink" title="A forEach variant that returns Self"></a>A <code>forEach</code> variant that returns <code>Self</code></h1><p>Fortunately, it’s not difficult to add this functionality. All we need is a method on <code>Sequence</code>that calls the passed-in function once for each element (like <code>forEach</code>) and then returns itself so that the chain can continue as if nothing happened. In other words, the method’s return type should be <code>Self</code>. I chose to call it <code>forEachPerform</code> to avoid ambiguities between it and the original <code>forEach</code> during type checking:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Sequence &#123;</span><br><span class="line">    /// Perform a side effect for each element in `self`.</span><br><span class="line">    @discardableResult</span><br><span class="line">    func forEachPerform(_ body: (Element) throws -&gt; ())</span><br><span class="line">        rethrows -&gt; Self</span><br><span class="line">    &#123;</span><br><span class="line">        try forEach(body)</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unlike <code>forEach</code>, we can insert this method into the chain like so:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .filter &#123; $0 % 2 == 0&#125;</span><br><span class="line">    .forEachPerform &#123; print($0) &#125;</span><br><span class="line">    .map &#123; $0 * $0 &#125;</span><br><span class="line">    .reduce(0, +)</span><br><span class="line">/* Prints:</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>I also found it useful to add a second method, which calls its function argument only once for the entire sequence and not once per element:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Sequence &#123;</span><br><span class="line">    /// Perform a side effect.</span><br><span class="line">    @discardableResult</span><br><span class="line">    func perform(_ body: (Self) throws -&gt; ())</span><br><span class="line">        rethrows -&gt; Self</span><br><span class="line">    &#123;</span><br><span class="line">        try body(self)</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is perfect for logging each intermediate result:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let sumOfSquaredEvenNumbers = numbers</span><br><span class="line">    .filter &#123; $0 % 2 == 0&#125;</span><br><span class="line">    .perform &#123; print(&quot;After filter: \($0)&quot;) &#125;</span><br><span class="line">    .map &#123; $0 * $0 &#125;</span><br><span class="line">    .perform &#123; print(&quot;After map: \($0)&quot;) &#125;</span><br><span class="line">    .reduce(0, +)</span><br><span class="line">/* Prints:</span><br><span class="line">After filter: [2, 4, 6, 8, 10]</span><br><span class="line">After map: [4, 16, 36, 64, 100]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="Self-consuming-sequences"><a href="#Self-consuming-sequences" class="headerlink" title="Self-consuming sequences"></a>Self-consuming sequences</h1><p>The new methods return <code>self</code> unchanged, so inserting them into a chain should be totally transparent. But note that the <code>Sequence</code> protocol makes no guarantees that implementations produce the same sequence of elements when iterated repeatedly.</p>
<p>Most conforming types obviously do guarantee this (like <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>), but suppose you have a <code>Sequence</code> that represents an incoming byte stream from a network socket: calling <code>forEachPerform</code> or <code>perform</code> on it will consume the sequence, leaving no bytes to process for subsequent operations.</p>
<p>If that’s a problem for you, you could either have the methods return an <code>Array&lt;Element&gt;</code>(thereby implicitly turning destructive sequences into repeatable ones) or to add the new methods on <a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener"><code>Collection</code></a> (which does guarantee non-destructive iteration).</p>
<h1 id="Making-it-lazy"><a href="#Making-it-lazy" class="headerlink" title="Making it lazy"></a>Making it lazy</h1><p>Another not-quite-transparent side effect of <code>forEachPerform</code> is that it doesn’t work well with <em>lazy sequences</em>.</p>
<p>The idea of a lazy sequence is that it should defer all work to produce the next element until the last possible moment, i.e. when an operation further down the chain actually requests that element. By looping over each element in the implementation of <code>forEachPerform</code>, we destroy any laziness the incoming sequence may have had.</p>
<p>To preserve the laziness, we can define our own lazy iterator and sequence types, named <code>LazyForEachIterator</code> and <code>LazyForEachSequence</code>. These work exactly like similar types in the standard library: instead of executing the side effect function immediately, they <em>store</em>the function and the incoming sequence, and then they <em>wait</em> until someone requests the next element. Only then will they in turn ask the base sequence for <em>its</em> next element and process it.</p>
<p>The code looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct LazyForEachIterator&lt;Base: IteratorProtocol&gt;</span><br><span class="line">    : IteratorProtocol</span><br><span class="line">&#123;</span><br><span class="line">    mutating func next() -&gt; Base.Element? &#123;</span><br><span class="line">        guard let nextElement = base.next() else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        perform(nextElement)</span><br><span class="line">        return nextElement</span><br><span class="line">    &#125;</span><br><span class="line">    var base: Base</span><br><span class="line">    let perform: (Base.Element) -&gt; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct LazyForEachSequence&lt;Base: Sequence&gt;</span><br><span class="line">    : LazySequenceProtocol</span><br><span class="line">&#123;</span><br><span class="line">    func makeIterator()</span><br><span class="line">        -&gt; LazyForEachIterator&lt;Base.Iterator&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        return LazyForEachIterator(</span><br><span class="line">            base: base.makeIterator(),</span><br><span class="line">            perform: perform)</span><br><span class="line">    &#125;</span><br><span class="line">    let base: Base</span><br><span class="line">    let perform: (Base.Element) -&gt; ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that our sequence type conforms to <a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_blank" rel="noopener"><code>LazySequenceProtocol</code></a>. This protocol inherits from <code>Sequence</code>. Its purpose is to provide lazy implementations of normally-eager operations.</p>
<p>When you call a method like <code>map</code> on a value that conforms to <code>LazySequenceProtocol</code>, the compiler will favor the lazy variant of <code>map</code> over the non-lazy version because one of Swift’s type inference rules is to pick the most specific overload that works under the given constraints.</p>
<p>To achieve the same effect for our method, we can extend <code>LazySequenceProtocol</code> with a variant of <code>forEachPerform</code> that returns a lazy sequence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension LazySequenceProtocol &#123;</span><br><span class="line">    func forEachPerform(_ body: @escaping (Element) -&gt; ())</span><br><span class="line">        -&gt; LazyForEachSequence&lt;Self&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        return LazyForEachSequence(base: self,</span><br><span class="line">            perform: body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This method differs in several aspects from the non-lazy version:</p>
<ul>
<li>The function parameter must be <code>@escaping</code> because we’re storing it.</li>
<li>It doesn’t support throwing functions because that wouldn’t work with lazy evaluation.</li>
<li>The return value is not marked as discardable because a lazy operation that no one ever executes later doesn’t make any sense.</li>
</ul>
<p>But the most important charateristic is what we discussed above: the method doesn’t perform any work except storing the base sequence and the function for later.</p>
<p>With this in place, <code>forEachPerform</code> will preserve the laziness of a sequence (notice the <code>.lazy</code> call):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let largeNumbersSquared = numbers</span><br><span class="line">    .lazy</span><br><span class="line">    .filter &#123; $0 &gt;= 5 &#125;</span><br><span class="line">    .forEachPerform &#123; print(&quot;After filter: \($0)&quot;) &#125;</span><br><span class="line">    .map &#123; $0 * $0 &#125;</span><br><span class="line">// Prints nothing</span><br></pre></td></tr></table></figure>
<p><em>Note: Actually, this exact code produces a compile error in Swift 4.0: “ambiguous use of ‘forEachPerform’”. It only works as shown here if I change the return type of Sequence.forEachPerform from Self to [Element]. I’m not quite sure why that is. As a workaround, you could give LazySequenceProtocol.forEachPerform a unique name.</em></p>
<p>Only when we access elements from the lazy sequence will the side effects for those elements be printed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Access the first two elements</span><br><span class="line">Array(largeNumbersSquared.prefix(2))</span><br><span class="line">/* Prints:</span><br><span class="line">After filter: 5</span><br><span class="line">After filter: 6</span><br><span class="line">*/</span><br><span class="line">// → [25, 36]</span><br></pre></td></tr></table></figure>
<p>Source: <a href="https://oleb.net/" target="_blank" rel="noopener">Ole Begemann</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/04/2017/objc-warnings-upgrading-to-swift-4/" class="prev">PREV</a><a href="/2017/11/04/2017/use-didset-when-initialling-an-object-in-swift/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://duc.ninja">Duc Ninja</a> , powered by <a href="https://twitter.com/duccuimia/" target="_blank">@duccuimia</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>
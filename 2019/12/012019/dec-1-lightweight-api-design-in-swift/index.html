<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <link rel="alternate" href="/atom.xml" title="Duc Ninja" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="One of the most powerful aspects of Swift is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types tha">
<meta name="keywords" content="duc, duc.ninja, ios developer, ducito, nnduc">
<meta property="og:type" content="article">
<meta property="og:title" content="Lightweight API Design in Swift">
<meta property="og:url" content="https://duc.ninja/2019/12/012019/dec-1-lightweight-api-design-in-swift/index.html">
<meta property="og:site_name" content="Duc Ninja">
<meta property="og:description" content="One of the most powerful aspects of Swift is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types tha">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-01T04:15:14.349Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lightweight API Design in Swift">
<meta name="twitter:description" content="One of the most powerful aspects of Swift is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types tha">
  <link rel="canonical" href="https://duc.ninja/2019/12/012019/dec-1-lightweight-api-design-in-swift/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Lightweight API Design in Swift | Duc Ninja</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duc Ninja</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">I'm an iOS engineer and a ninja as well.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-blog">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-home"></i>Blog</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-my-info">
      
    

    <a href="https://linkedin.com/in/nnduc" rel="noopener" target="_blank"><i class="fa fa-fw fa-user"></i>My info</a>

  </li>
      
    
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://duc.ninja/2019/12/012019/dec-1-lightweight-api-design-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Duc Ninja">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/images/logo/icon-310x310.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duc Ninja">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            Lightweight API Design in Swift
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-01 10:30:00 / Modified: 11:15:14" itemprop="dateCreated datePublished" datetime="2019-12-01T10:30:00+07:00">2019-12-01</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>One of the most powerful aspects of <code>Swift</code> is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types that are easier to understand and use — it also lets us create APIs that give a very lightweight first impression, while still progressively disclosing more power and complexity if needed.</p>
<p>Let’s take a look at some of the core language features that enable those kind of lightweight APIs to be created, and how we can use them to make a feature or system much more capable through the power of composition.</p>
<a id="more"></a>

<h2 id="A-trade-off-between-power-and-ease-of-use"><a href="#A-trade-off-between-power-and-ease-of-use" class="headerlink" title="A trade-off between power and ease of use"></a><a href="#a-trade-off-between-power-and-ease-of-use">A trade-off between power and ease of use</a></h2><p>Often when we design how our various types and functions will interact with each other, we have to find some form of balance between power and ease of use. Make things too simple, and they might not be flexible enough to enable our features to continuously evolve — but on the other hand, too much complexity often leads to frustration, misunderstandings, and ultimately bugs.</p>
<p>As an example, let’s say that we’re working on an app that lets our users apply various filters to images — for example to be able to edit photos from their camera roll or library. Each filter is made up of an array of image transforms, and is defined using an <code>ImageFilter</code> struct, that looks like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">Icon</span></span><br><span class="line">    <span class="keyword">var</span> transforms: [<span class="type">ImageTransform</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When it comes to the <code>ImageTransform</code> API, it’s currently modeled as a protocol, which is then conformed to by various types that implement our individual transform operations:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(to image: Image)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PortraitImageTransform</span>: <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> zoomMultiplier: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(to image: Image)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GrayScaleImageTransform</span>: <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> brightnessLevel: <span class="type">BrightnessLevel</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(to image: Image)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One core advantage of the above approach is that, since each transform is implemented as its own type, we’re free to let each type define its own set of properties and parameters — such as how <code>GrayScaleImageTransform</code> accepts a <code>BrightnessLevel</code> to use when turning an image into grayscale.</p>
<p>We can then combine as many of the above types as we wish in order to form each filter — for example one that gives an image a bit of a <em>“dramatic”</em> look through a series of transforms:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter = <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">"Dramatic"</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        <span class="type">PortraitImageTransform</span>(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        <span class="type">ContrastBoostImageTransform</span>(),</span><br><span class="line">        <span class="type">GrayScaleImageTransform</span>(brightnessLevel: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So far so good — but if we take a closer look at the above API, it can definitely be argued that we’ve chosen to optimize for power and flexibility, rather than for ease of use. Since each transform is implemented as an individual type, it’s not immediately clear what kind of transforms that our code base contains, since there’s no single place in which they can all be instantly discovered.</p>
<p>Compare that to if we would’ve chosen to use an enum to model our transforms instead — which would’ve given us a very clear overview of all possible options:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> portrait(zoomMultiplier: <span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> grayScale(<span class="type">BrightnessLevel</span>)</span><br><span class="line">    <span class="keyword">case</span> contrastBoost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using an enum would’ve also resulted in very nice and readable call sites — making our API feel much more lightweight and easy to use, since we would’ve been able to construct any number of transforms using <em>dot-syntax</em>, like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter = <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">"Dramatic"</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>However, while Swift enums are a fantastic tool in many different situations, this isn’t really one of them.</p>
<p>Since each transform needs to perform vastly different image operations, using an enum in this case would’ve forced us to write one massive <code>switch</code> statement to handle each and every one of those operations — which would most likely become somewhat of a nightmare to maintain.</p>
<h2 id="Light-as-an-enum-capable-as-a-struct"><a href="#Light-as-an-enum-capable-as-a-struct" class="headerlink" title="Light as an enum, capable as a struct"></a><a href="#light-as-an-enum-capable-as-a-struct">Light as an enum, capable as a struct</a></h2><p>Thankfully, there’s a third option — which sort of gives us the best of both worlds. Rather than using either a protocol or an enum, let’s instead use a struct, which in turn will contain a closure that encapsulates a given transform’s various operations:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> closure: (<span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(to image: Image)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that the <code>apply(to:)</code> method is no longer required, but we still add it both for backward compatibility, and to make our call sites read a bit nicer.</p>
<p>With the above in place, we can now use static factory methods and properties to create our transforms — each of which can still be individually defined and have its own set of parameters:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> contrastBoost: <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">portrait</span><span class="params">(withZoomMultipler multiplier: Double)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">grayScale</span><span class="params">(withBrightness brightness: BrightnessLevel)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That <code>Self</code> can now be used as a return type for static factory methods is one of the small but significant improvements introduced in Swift 5.1.</p>
<p>The beauty of the above approach is that we’re back to the same level of flexibility and power that we had when defining <code>ImageTransform</code> as a protocol, while still being able to use a more or less identical dot-syntax as when using an enum:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter = <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">"Dramatic"</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(withZoomMultipler: <span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(withBrightness: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The fact that dot syntax isn’t tied to enums, but can instead be used with any sort of static API, is incredibly powerful — and even lets us encapsulate things one step further, by modeling the above filter creation as a computed static property as well:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> dramatic: <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageFilter</span>(</span><br><span class="line">            name: <span class="string">"Dramatic"</span>,</span><br><span class="line">            icon: .drama,</span><br><span class="line">            transforms: [</span><br><span class="line">                .portrait(withZoomMultipler: <span class="number">2.1</span>),</span><br><span class="line">                .contrastBoost,</span><br><span class="line">                .grayScale(withBrightness: .dark)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The result of all of the above is that we can now take a really complex series of tasks — applying image filters and transforms — and encapsulate them into an API that, on the surface level, appears as lightweight as simply passing a value to a function:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered = image.withFilter(.dramatic)</span><br></pre></td></tr></table></figure>

<p>While it’s easy to dismiss the above change as purely adding <em>”syntactic sugar”</em>, we haven’t only improved the way our API reads, but also the way in which its parts can be composed. Since all transforms and filters are now just values, they can be combined in a huge number of ways — which doesn’t only make them more lightweight, but also much more flexible as well.</p>
<h2 id="Variadic-parameters-and-further-composition"><a href="#Variadic-parameters-and-further-composition" class="headerlink" title="Variadic parameters and further composition"></a><a href="#variadic-parameters-and-further-composition">Variadic parameters and further composition</a></h2><p>Next, let’s take a look at another really interesting language feature — variadic parameters — and what kind of API design choices that they can unlock.</p>
<p>Let’s now say that we’re working on an app that uses shape-based drawing in order to create parts of its user interface, and that we’ve used a similar struct-based approach as above in order to model how each shape is drawn into a <code>DrawingContext</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> drawing: (<span class="keyword">inout</span> <span class="type">DrawingContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Above we use the <code>inout</code> keyword to enable a value type (<code>DrawingContext</code>) to be passed as if it was a reference. For more on that keyword, and value semantics in general, check out Utilizing value semantics in Swift.</p>
<p>Just like how we enabled <code>ImageTransform</code> values to be easily created using static factory methods before, we’re now also able to encapsulate each shape’s drawing code within completely separate methods — like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(at point: Point, sideLength: Double)</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> origin = point.movedBy(</span><br><span class="line">                x: -sideLength / <span class="number">2</span>,</span><br><span class="line">                y: -sideLength / <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            context.move(to: origin)</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength, y: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(y: sideLength))</span><br><span class="line">            context.drawLine(to: origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since each shape is simply modeled as a value, drawing arrays of them becomes quite easy — all we have to do is to create an instance of <code>DrawingContext</code>, and then pass that into each shape’s closure in order to build up our final image:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> shapes: [Shape])</span></span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="type">DrawingContext</span>()</span><br><span class="line"></span><br><span class="line">    shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">        context.move(to: .zero)</span><br><span class="line">        shape.drawing(&amp;context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context.makeImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calling the above function also looks quite elegant, since we’re again able to use dot syntax to heavily reduce the amount of syntax needed to perform our work:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">image</span> = <span class="built_in">draw</span>([</span><br><span class="line">    .circle(<span class="built_in">at</span>: point, <span class="built_in">radius</span>: <span class="number">10</span>),</span><br><span class="line">    .square(<span class="built_in">at</span>: point, sideLength: <span class="number">5</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>However, let’s see if we can take things one step further using variadic parameters. While not a feature unique to Swift, when combined with Swift’s really flexible parameter naming capabilities, using variadic parameters can yield some really interesting results.</p>
<p>When a parameter is marked as variadic (by adding the <code>...</code> suffix to its type), we’re essentially able to pass any number of values to that parameter — and the compiler will automatically organize those values into an array for us, like this:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> shapes: Shape...)</span></span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Within our function, 'shapes' is still an array:</span></span><br><span class="line">    shapes.forEach &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With the above change in place, we can now remove all of the array literals from the calls to our <code>draw</code> function, and instead make them look like this:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">image</span> = <span class="built_in">draw</span>(.circle(<span class="built_in">at</span>: point, <span class="built_in">radius</span>: <span class="number">10</span>),</span><br><span class="line">                 .square(<span class="built_in">at</span>: point, sideLength: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>That might not seem like such a big change, but especially when designing more lower-level APIs that are intended to be used to create more higher-level values (such as our <code>draw</code> function), using variadic parameters can make those kind of APIs feel much more lightweight and convenient.</p>
<p>However, one drawback of using variadic parameters is that an array of pre-computed values can no longer be passed as a single argument. Thankfully, that can quite easily be fixed in this case, by creating a special <code>group</code> shape that — just like the <code>draw</code> function itself — iterates over an array of underlying shapes and draws them:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension </span><span class="keyword">Shape </span>&#123;</span><br><span class="line">    static func group(_ <span class="keyword">shapes: </span>[<span class="keyword">Shape]) </span>-&gt; Self &#123;</span><br><span class="line">        <span class="keyword">Shape </span>&#123; <span class="built_in">context</span> in</span><br><span class="line">            <span class="keyword">shapes.forEach </span>&#123; <span class="keyword">shape </span>in</span><br><span class="line">                <span class="built_in">context</span>.<span class="keyword">move(to: </span>.zero)</span><br><span class="line">                <span class="keyword">shape.drawing(&amp;context)</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With the above in place, we can now once again easily pass a group of pre-computed <code>Shape</code> values to our <code>draw</code> function, like this:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> shapes: [Shape] = loadShapes()</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">image</span> = <span class="built_in">draw</span>(.group(shapes))</span><br></pre></td></tr></table></figure>

<p>What’s really cool though, is that not only does the above <code>group</code> API enable us to construct arrays of shapes — it also enables us to much more easily compose multiple shapes into more higher-level components. For example, here’s how we could express an entire drawing (such as a logo), using a group of composed shapes:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Shape &#123;</span><br><span class="line">    <span class="keyword">static</span> func logo(withSize <span class="keyword">size</span>: <span class="keyword">Size</span>) -&gt; Self &#123;</span><br><span class="line">        .<span class="keyword">group</span>([</span><br><span class="line">            .rectangle(at: <span class="keyword">size</span>.centerPoint, <span class="keyword">size</span>: <span class="keyword">size</span>),</span><br><span class="line">            .text(<span class="string">"The Drawing Company"</span>, fittingInto: <span class="keyword">size</span>),</span><br><span class="line">            ...</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since the above logo is a <code>Shape</code> just like any other, we can easily draw it with a single call to our <code>draw</code> method, using the same elegant dot syntax as we used before:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let logo = draw(.logo(<span class="name">withSize</span>: size))</span><br></pre></td></tr></table></figure>

<p>What’s interesting is that while our initial goal might’ve been to make our API more lightweight, in doing so we also made it more composable and more flexible as well.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><a href="#conclusion">Conclusion</a></h2><p>The more tools that we add to our <em>“API designer’s toolbox”</em>, the more likely it is that we’ll be able to design APIs that strike the right balance between power, flexibility and ease of use.</p>
<p>Making APIs as lightweight as possible might not be our ultimate goal, but by trimming our APIs down as much as we can, we also often discover how they can be made more powerful — by making the way we create our types more flexible, and by enabling them to be composed. All of which can aid us in achieving that perfect balance between simplicity and power.</p>
<p>Happy coding!</p>
<p>[Source: swiftbysundell]</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/262019/nov-26-xcode11-ios12/" rel="next" title="Allow App Created in Xcode 11 to Run on iOS 12 and Lower">
                  <i class="fa fa-chevron-left"></i> Allow App Created in Xcode 11 to Run on iOS 12 and Lower
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-trade-off-between-power-and-ease-of-use"><span class="nav-number">1.</span> <span class="nav-text">A trade-off between power and ease of use</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Light-as-an-enum-capable-as-a-struct"><span class="nav-number">2.</span> <span class="nav-text">Light as an enum, capable as a struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Variadic-parameters-and-further-composition"><span class="nav-number">3.</span> <span class="nav-text">Variadic parameters and further composition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">4.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/assets/images/logo/icon-310x310.png"
      alt="Duc Ninja">
  <p class="site-author-name" itemprop="name">Duc Ninja</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://github.com/ducito" title="GitHub &rarr; https://github.com/ducito" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="mailto:nnduc@icloud.com" title="E-Mail &rarr; mailto:nnduc@icloud.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://twitter.com/duc_ninja" title="Twitter &rarr; https://twitter.com/duc_ninja" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://www.facebook.com/duc.ninja" title="FB Page &rarr; https://www.facebook.com/duc.ninja" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="skype:ducnn01?call|chat" title="Skype &rarr; skype:ducnn01?call|chat" rel="noopener" target="_blank"><i class="fa fa-fw fa-skype"></i></a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Duc Ninja</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/muse.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
